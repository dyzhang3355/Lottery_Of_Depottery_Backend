{
  "language": "Solidity",
  "sources": {
    "src/MyToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// The line above is recommended and let you define the license of your contract\n// Solidity files have to start with this pragma.\n// It will be used by the Solidity compiler to validate its version.\npragma solidity ^0.8.17;\n\n//import \"hardhat/console.sol\"; // fix for conflict with forge-std/Test.sol in tests.\n\n// This is the main building block for smart contracts.\ncontract MyToken {\n    bool      public  gameOngoing;\n\n    // admin side.\n    address   public  admin;\n    uint32    public  ticketPrice;\n    uint8     public  prizePercentage; // ranging from 1~90.\n    uint32    public  gameRound;\n    uint8[6]  public  winningNums;     // The 6 winning numbers in a game. Each should be between 1~49, inclusive.\n\n    // player side.\n    uint32    public  playerNum;       // The number of players. This is to loop through mapping 'ticketOrders'.\n    address[] public  playerList;\n    address[] public  winnerList;\n    mapping(address => LotteryTicket) public ticketOrders;\n    //mapping(uint32 => uint8[6]) public winningNumbers; // winning numbers records. The key is the round number, while the value (uint8[6]) is the corresponding winning number.\n\n    struct LotteryTicket {\n        //TODO: bring back. uint32 ticketCnt; // the number of tickets a player buys in a game. This is to loop through all the tickets one buys.\n        //TODO: bring back. uint8[][6] playerLotteryNums;  // a player can buy multiple tickets in a game.\n        bool   isValid;              // true: player's ticket is valid. Otherwise, invalid.\n        bool   isClaimed;\n        uint32 playerGameRound;      // the latest game round that a player is in.\n        uint8[6] playerLotteryNums;  // a player can buy multiple tickets in a game.\n    }\n\n    constructor() {\n        admin = msg.sender;\n        gameRound = 1;            // increase by 1 every time when a game is finished.\n        ticketPrice = 500000 wei; // about one US dollar.\n        prizePercentage = 70;     // 70% of the balance in pool is used for the Prize.\n        gameOngoing = false;      // true: the game is ongoing. false: game is paused/cancelled.\n        for (uint8 i = 0; i < 6; i++) {\n            winningNums[i] = 0;   // set the initial winning number as 0.\n        }\n    }\n\n    mapping(address => uint256) balances;\n\n    modifier onlyAdmin () { // only admin can enable/pause/cancel a game and change the ticket price and prize percentage.\n        require(msg.sender == admin, \"Only the contract admin can call this function.\");\n        _;\n    }\n\n    modifier gameIsOngoing () { // only admin can enable/pause/cancel a game and change the ticket price and prize percentage.\n        require(gameOngoing == true, \"Game is not ongoing.\");\n        _;\n    }\n\n    modifier onlyValidTicket () { // a player needs a valid ticket to claim a prize or cancel a ticket.\n        require(ticketOrders[msg.sender].isValid == true, \"The ticket is invalid and thus cannot proceed.\");\n        _;\n    }\n\n    modifier onlyOneTicket () { // a player is allowed to buy at msot one ticket in a game. This limit may be removed later. // test_08 fix.\n        require((ticketOrders[msg.sender].isValid == false) || (ticketOrders[msg.sender].playerGameRound != gameRound), \"Only one ticket at most in a game round.\");\n        _;\n    }\n\n    modifier hasPlayers () { // a player is allowed to buy at msot one ticket in a game. This limit may be removed later. // test_08 fix.\n        require(playerNum > 0, \"There should be at least one player in a game.\");\n        _;\n    }\n\n    event getTicketPriceEvent();\n    function setTicketPrice(uint32 newPrice) onlyAdmin external {\n        require(newPrice > 0, \"The new ticket price should be larger than 0.\");\n        ticketPrice = newPrice;\n    }\n\n    function setPrizePercentage(uint8 newPercent) onlyAdmin external {\n        require((newPercent > 0) && (newPercent <= 90), \"The new percentage should be > 0 and <= 90.\");\n        prizePercentage = newPercent;\n    }\n\n    function enableGame() onlyAdmin external {\n        gameOngoing = true;\n    }\n    function pauseGame() onlyAdmin external {\n        gameOngoing = false;\n    }\n\n    // A game can only be cancelled (to prevent any new player from buying tickets) when it has been paused to avoid any synchronization issue.\n    function adminCancelGame() external {\n        require(gameOngoing == false, \"Please pause the game before cancelling it.\");\n        // return ticket fees back to players if a game is cancelled.\n        for (uint32 i = 0; i < playerNum; i++) {\n            if (ticketOrders[playerList[i]].playerGameRound == gameRound) { // make sure that a player has joined the latest game before refunding.\n                payable(playerList[i]).transfer(ticketPrice);\n            }\n        }\n    }\n\n    // Player side.\n    function buyTicket(uint8[6] memory newNums) gameIsOngoing onlyOneTicket external payable { // test_04 fix.\n        require(msg.value == ticketPrice, \"Incorrect paid Ethers, check the price by function getTicketPrice and try again.\");\n        bool hasDuplicate = false;\n        for (uint8 i = 0; i < 5; i++) {\n            for (uint8 j = (i + 1); j < 6; j++) {\n                if (newNums[i] == newNums[j]) {\n                    hasDuplicate = true;\n                }\n            }\n        }\n        require(hasDuplicate == false, \"No duplicate numbers are allowed.\");\n\n        // numbers should be between 1~49. // issue_1 fix.\n        bool validNums = true;\n        for (uint8 i = 0; i < 6; i++) {\n            if (newNums[i] < 1 || newNums[i] > 49) {\n                validNums = false;\n            }\n        }\n        require(validNums == true, \"All selected numbers should be between 1~49, inclusive.\");\n\n        ticketOrders[msg.sender].playerGameRound = gameRound;\n        ticketOrders[msg.sender].isValid = true;\n        ticketOrders[msg.sender].isClaimed = false;\n        for (uint8 i = 0; i < newNums.length; i++) {\n            ticketOrders[msg.sender].playerLotteryNums[i] = newNums[i];\n        }\n\n        playerList.push(msg.sender);\n        //playerList[playerNum] = msg.sender;\n        playerNum += 1;  \n    }\n\n    function playerCancelTicket() onlyValidTicket external {\n        ticketOrders[msg.sender].isValid = false;\n        payable(msg.sender).transfer(ticketPrice);\n    }\n\n    function draw() onlyAdmin hasPlayers external {\n        gameOngoing = false; // disable game to prevent any player from buying a ticket after the winning numbers are generated.\n        winningNums = generateNumbers();\n\n        //address[] memory winnerList;\n        // check winners and get the total number of winners.\n        for (uint32 i = 0; i < playerNum; i++) {\n            if ((ticketOrders[playerList[i]].playerGameRound == gameRound) && (ticketOrders[playerList[i]].isValid == true)) { // make sure that a player has joined the latest game and has not cancelled. // issue_3 fix.\n                bool isWinner = checkWinner(ticketOrders[playerList[i]].playerLotteryNums, winningNums);\n                if (isWinner) {\n                    winnerList.push(playerList[i]);\n                }\n                //payable(playerList[i]).transfer(ticketPrice); // issue_4 fix by removing this line.\n            }\n        }\n\n        // divide the prize and transfer.\n        if (winnerList.length > 0) {\n            uint256 winnerPrize =  (address(this).balance * prizePercentage / (100 *winnerList.length)); // issue_2 fix.\n            for (uint32 i = 0; i < winnerList.length; i++) {\n                require(ticketOrders[winnerList[i]].isClaimed == false, \"Winner has already claimed the prize.\");\n                ticketOrders[winnerList[i]].isClaimed = true;\n                payable(winnerList[i]).transfer(winnerPrize);\n            }\n        }\n\n        // prepare for the next game.\n        gameRound += 1;\n        playerNum = 0;\n        delete playerList;\n    }\n\n    function getWinningNumber() external view returns (uint32, uint8[6] memory) {\n        return  (gameRound - 1, winningNums); // gameRound needs to minus 1 because it is increased every time a round of winning nubmers is generated.\n    }\n\n    // for players to check their own number and corresponding game round in case they forgot them.\n    function getPlayerNumber() external view returns (uint32, uint8[6] memory) {\n        return (ticketOrders[msg.sender].playerGameRound, ticketOrders[msg.sender].playerLotteryNums);\n    }\n\n    // for players to check the ticket price before buying a ticket.\n    function getTicketPrice() external view returns (uint32) {\n        return ticketPrice;\n    }\n\n    // for players to check the total money in the pool before buying a ticket.\n    function getPoolBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    // for players to check the expected prize before buying a ticket.\n    function getExpectedPrize() external view returns (uint256) {\n        return (address(this).balance * prizePercentage / 100); // default 70%.\n    }\n\n    // Newly Added\n    function getPrizePercentage() external view returns (uint256) {\n        return (prizePercentage / 100); // default 70%.\n    }\n\n    // Newly Added\n    function getGameRound() external view returns (uint32) {\n        return gameRound;\n    }\n\n    // Newly Added\n    function getGameStatus() external view returns (string memory) {\n        string memory gameStatus = gameOngoing ? \"Ongoing\" : \"Paused/Cancelled\";\n        return gameStatus;\n    }\n\n    // for admin to donate money to charitable organization.\n    // This is the main purpose of this lottery game.\n    function doCharityDonation() onlyAdmin external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function generateNumbers() private view returns(uint8[6] memory) {\n        uint8[6] memory numbers;\n        uint randomNumber = uint(keccak256(abi.encodePacked(block.timestamp, msg.sender)));\n        \n        for(uint8 i=0; i<6; i++) {\n            uint8 number = uint8(randomNumber % 49) + 1;\n            while(numberExists(numbers, number)) {\n                randomNumber = uint(keccak256(abi.encodePacked(randomNumber)));\n                number = uint8(randomNumber % 49) + 1;\n            }\n            numbers[i] = number;\n            randomNumber = uint(keccak256(abi.encodePacked(randomNumber)));\n        }\n        \n        return numbers;\n    }\n    \n    function numberExists(uint8[6] memory array, uint8 number) private pure returns(bool) {\n        for(uint8 i=0; i<array.length; i++) {\n            if(array[i] == number) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function checkWinner(uint8[6] memory playerNums, uint8[6] memory winnerNums) private pure returns(bool) {\n        require(playerNums.length == winnerNums.length, \"Player number length should be equal to winner number length.\");\n        bool isWinner = true;\n        for(uint8 i =0; i < winnerNums.length; i++) {\n            if (playerNums[i] != winnerNums[i]) {\n                isWinner = false;\n                break;\n            }\n        }\n        return isWinner;\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}