{
  "language": "Solidity",
  "sources": {
    "src/MyToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// The line above is recommended and let you define the license of your contract\n// Solidity files have to start with this pragma.\n// It will be used by the Solidity compiler to validate its version.\npragma solidity ^0.8.17;\n\n//import \"hardhat/console.sol\"; // fix for conflict with forge-std/Test.sol in tests.\n\n// This is the main building block for smart contracts.\nimport \"./PoolWithHigherInterest.sol\";\n\ncontract MyToken {\n\n    struct User {\n\t    uint balance;\n        uint lastUpdateTime;\n        uint interestRate;\n        string name;\n} \n\n    mapping (address => User) public users;\n    address payable admin;\n    uint public totalInterest;\n    uint public lastUpdate;\n    uint public interestRate;\n    uint public investedAmount;\n    PoolWithHigherInterest pool;\n\n    //constructor(address investmentAddress) {\n    constructor() {\n        admin = payable(msg.sender);\n        totalInterest = 0;\n        lastUpdate = block.timestamp;\n        interestRate = 2;\n        investedAmount = 0;\n        //Changed. pool = PoolWithHigherInterest(investmentAddress);\n        pool = PoolWithHigherInterest(0x4070C76A1635eCd0538388F8948806420814e1d0);\n        pool.register(\"KK\");\n        gameRound = 1;            // increase by 1 every time when a game is finished.\n        ticketPrice = 500000 wei; // about one US dollar.\n        prizePercentage = 70;     // 70% of the balance in pool is used for the Prize.\n        gameOngoing = false;      // true: the game is ongoing. false: game is paused/cancelled.\n        for (uint8 i = 0; i < 6; i++) {\n            winningNums[i] = 0;   // set the initial winning number as 0.\n        }\n    }\n\n    modifier onlyOwner{\n        require(msg.sender == admin, \"can only be called by the owner\");\n        _;\n    }\n\n    modifier isRegistered() {\n        require(users[msg.sender].lastUpdateTime > 0, \"This user is not registered\");\n        _;\n    }\n\n    function getBalance() public view isRegistered returns (uint) {\n        return users[msg.sender].balance + calculateInterest(msg.sender);\n    }\n\n    function getUserInterestRate(address user) public view isRegistered returns (uint) {\n        require(msg.sender == admin || msg.sender == user, \"You can not get other people's inerestRate.\");\n        return users[user].interestRate;\n    }\n\n    function getFunds() public view onlyOwner returns (uint) {\n        return address(this).balance;\n    }\n\n    function getInterestRate() public view onlyOwner returns (uint) {\n        return interestRate;\n    }\n\n    function getInvestedAmount() public view onlyOwner returns (uint){\n        return investedAmount;\n    }\n\n    function changeRate(uint newRate) external onlyOwner{\n        interestRate = newRate;\n    }\n\n    function manuallyInvest(uint amount) public onlyOwner{\n        require(amount > pool.getLowestDepositAmount(), \"Deposit amount can not be less than lowestDepositAmount\");\n\n        investInAnotherPool(amount);\n    }\n\n    function manuallyWithdraw(uint amount) public onlyOwner{\n        require(investedAmount >= amount, \"Don't have enough amount to withdraw\");\n\n        withdrawFromAnotherPool(amount);\n    }\n\n    function register(string memory name) public {\n        require(users[msg.sender].lastUpdateTime == 0, \"This user is already registered\");\n        require((bytes(name)).length != 0, \"Name is not provided\");\n        User memory user = User({\n                balance: 0,\n                lastUpdateTime: block.timestamp,\n                interestRate: interestRate,\n                name: name\n            });\n        users[msg.sender] = user;\n    }\n\n    function deposit() external isRegistered payable  {\n        require(msg.value > 0, \"Deposit amount can not be zero\");\n\n        updateBalance(msg.sender);\n        \n        users[msg.sender].balance += msg.value;\n        users[msg.sender].lastUpdateTime = block.timestamp;\n        if(address(this).balance > pool.getLowestDepositAmount()){\n            investedAmount += address(this).balance;\n            investInAnotherPool(address(this).balance);\n        }\n    }\n\n    function withdraw(uint amount) external isRegistered {\n        require(amount > 0, \"Withdrawal amount must be greater than zero\");\n        updateBalance(msg.sender);\n        require(users[msg.sender].balance >= amount, \"Insufficient balance\");\n\n        if(address(this).balance < amount){\n            investedAmount -= amount - address(this).balance;\n            withdrawFromAnotherPool(amount - address(this).balance);\n        }\n\n        users[msg.sender].balance -= amount;\n        users[msg.sender].lastUpdateTime = block.timestamp;\n        require(address(this).balance > amount, \"not enough\");\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Withdrawal failed\");\n    }\n\n    function investInAnotherPool(uint amount) internal{\n        pool.deposit{value: amount}();\n        lastUpdate = block.timestamp;\n    } \n\n    function withdrawFromAnotherPool(uint amount) internal{\n        pool.withdraw(amount);\n        lastUpdate = block.timestamp;\n    }\n\n    function updateBalance(address user)internal{\n        uint interest = calculateInterest(user);\n        lastUpdate = block.timestamp;\n        totalInterest += interest;\n        users[user].balance += interest;\n        users[user].lastUpdateTime = block.timestamp;\n    }\n\n    function calculateInterest(address user) internal view returns(uint){\n        uint timePassed = block.timestamp - users[user].lastUpdateTime;\n        uint interest = (users[user].balance * interestRate * timePassed) / (365 days * 100);\n        return interest;\n    }\n\n    bool      public  gameOngoing;\n\n    // admin side.\n    uint32    public  ticketPrice;\n    uint8     public  prizePercentage; // ranging from 1~90.\n    uint32    public  gameRound;\n    uint8[6]  public  winningNums;     // The 6 winning numbers in a game. Each should be between 1~49, inclusive.\n\n    // player side.\n    uint32    public  playerNum;       // The number of players. This is to loop through mapping 'ticketOrders'.\n    address[] public  playerList;\n    address[] public  winnerList;\n    mapping(address => LotteryTicket) public ticketOrders;\n    //mapping(uint32 => uint8[6]) public winningNumbers; // winning numbers records. The key is the round number, while the value (uint8[6]) is the corresponding winning number.\n\n    struct LotteryTicket {\n        //TODO: bring back. uint32 ticketCnt; // the number of tickets a player buys in a game. This is to loop through all the tickets one buys.\n        //TODO: bring back. uint8[][6] playerLotteryNums;  // a player can buy multiple tickets in a game.\n        bool   isValid;              // true: player's ticket is valid. Otherwise, invalid.\n        bool   isClaimed;\n        uint32 playerGameRound;      // the latest game round that a player is in.\n        uint8[6] playerLotteryNums;  // a player can buy multiple tickets in a game.\n    }\n\n    mapping(address => uint256) balances;\n\n    modifier onlyAdmin () { // only admin can enable/pause/cancel a game and change the ticket price and prize percentage.\n        require(msg.sender == admin, \"Only the contract admin can call this function.\");\n        _;\n    }\n\n    modifier gameIsOngoing () { // only admin can enable/pause/cancel a game and change the ticket price and prize percentage.\n        require(gameOngoing == true, \"Game is not ongoing.\");\n        _;\n    }\n\n    modifier onlyValidTicket () { // a player needs a valid ticket to claim a prize or cancel a ticket.\n        require(ticketOrders[msg.sender].isValid == true, \"The ticket is invalid and thus cannot proceed.\");\n        _;\n    }\n\n    modifier onlyOneTicket () { // a player is allowed to buy at msot one ticket in a game. This limit may be removed later. // test_08 fix.\n        require((ticketOrders[msg.sender].isValid == false) || (ticketOrders[msg.sender].playerGameRound != gameRound), \"Only one ticket at most in a game round.\");\n        _;\n    }\n\n    modifier hasPlayers () { // a player is allowed to buy at msot one ticket in a game. This limit may be removed later. // test_08 fix.\n        require(playerNum > 0, \"There should be at least one player in a game.\");\n        _;\n    }\n\n    function setTicketPrice(uint32 newPrice) onlyAdmin external {\n        require(newPrice > 0, \"The new ticket price should be larger than 0.\");\n        ticketPrice = newPrice;\n    }\n\n    function setPrizePercentage(uint8 newPercent) onlyAdmin external {\n        require((newPercent > 0) && (newPercent <= 90), \"The new percentage should be > 0 and <= 90.\");\n        prizePercentage = newPercent;\n    }\n\n    function enableGame() onlyAdmin external {\n        gameOngoing = true;\n    }\n    function pauseGame() onlyAdmin external {\n        gameOngoing = false;\n    }\n\n    // A game can only be cancelled (to prevent any new player from buying tickets) when it has been paused to avoid any synchronization issue.\n    function adminCancelGame() external {\n        require(gameOngoing == false, \"Please pause the game before cancelling it.\");\n        // return ticket fees back to players if a game is cancelled.\n        for (uint32 i = 0; i < playerNum; i++) {\n            if (ticketOrders[playerList[i]].playerGameRound == gameRound) { // make sure that a player has joined the latest game before refunding.\n                payable(playerList[i]).transfer(ticketPrice);\n            }\n        }\n    }\n\n    // Player side.\n    function buyTicket(uint8[6] memory newNums) gameIsOngoing onlyOneTicket external payable { // test_04 fix.\n        require(msg.value == ticketPrice, \"Incorrect paid Ethers, check the price by function getTicketPrice and try again.\");\n        bool hasDuplicate = false;\n        for (uint8 i = 0; i < 5; i++) {\n            for (uint8 j = (i + 1); j < 6; j++) {\n                if (newNums[i] == newNums[j]) {\n                    hasDuplicate = true;\n                }\n            }\n        }\n        require(hasDuplicate == false, \"No duplicate numbers are allowed.\");\n\n        // numbers should be between 1~49. // issue_1 fix.\n        bool validNums = true;\n        for (uint8 i = 0; i < 6; i++) {\n            if (newNums[i] < 1 || newNums[i] > 49) {\n                validNums = false;\n            }\n        }\n        require(validNums == true, \"All selected numbers should be between 1~49, inclusive.\");\n\n        ticketOrders[msg.sender].playerGameRound = gameRound;\n        ticketOrders[msg.sender].isValid = true;\n        ticketOrders[msg.sender].isClaimed = false;\n        for (uint8 i = 0; i < newNums.length; i++) {\n            ticketOrders[msg.sender].playerLotteryNums[i] = newNums[i];\n        }\n\n        playerList.push(msg.sender);\n        //playerList[playerNum] = msg.sender;\n        playerNum += 1;  \n    }\n\n    function playerCancelTicket() onlyValidTicket external {\n        ticketOrders[msg.sender].isValid = false;\n        payable(msg.sender).transfer(ticketPrice);\n    }\n\n    function draw() onlyAdmin hasPlayers external {\n        gameOngoing = false; // disable game to prevent any player from buying a ticket after the winning numbers are generated.\n        winningNums = generateNumbers();\n\n        //address[] memory winnerList;\n        // check winners and get the total number of winners.\n        for (uint32 i = 0; i < playerNum; i++) {\n            if ((ticketOrders[playerList[i]].playerGameRound == gameRound) && (ticketOrders[playerList[i]].isValid == true)) { // make sure that a player has joined the latest game and has not cancelled. // issue_3 fix.\n                bool isWinner = checkWinner(ticketOrders[playerList[i]].playerLotteryNums, winningNums);\n                if (isWinner) {\n                    winnerList.push(playerList[i]);\n                }\n                //payable(playerList[i]).transfer(ticketPrice); // issue_4 fix by removing this line.\n            }\n        }\n\n        // divide the prize and transfer.\n        if (winnerList.length > 0) {\n            uint256 winnerPrize =  (address(this).balance * prizePercentage / (100 *winnerList.length)); // issue_2 fix.\n            for (uint32 i = 0; i < winnerList.length; i++) {\n                require(ticketOrders[winnerList[i]].isClaimed == false, \"Winner has already claimed the prize.\");\n                ticketOrders[winnerList[i]].isClaimed = true;\n                payable(winnerList[i]).transfer(winnerPrize);\n            }\n        }\n\n        // prepare for the next game.\n        gameRound += 1;\n        playerNum = 0;\n        delete playerList;\n        delete winnerList;\n    }\n\n    function getWinningNumber() external view returns (uint32, uint8[6] memory) {\n        return  (gameRound - 1, winningNums); // gameRound needs to minus 1 because it is increased every time a round of winning nubmers is generated.\n    }\n\n    // for players to check their own number and corresponding game round in case they forgot them.\n    function getPlayerNumber() external view returns (uint32, uint8[6] memory) {\n        return (ticketOrders[msg.sender].playerGameRound, ticketOrders[msg.sender].playerLotteryNums);\n    }\n\n    // for players to check the ticket price before buying a ticket.\n    function getTicketPrice() external view returns (uint32) {\n        return ticketPrice;\n    }\n\n    // for players to check the total money in the pool before buying a ticket.\n    function getPoolBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    // for players to check the expected prize before buying a ticket.\n    function getExpectedPrize() external view returns (uint256) {\n        return (address(this).balance * prizePercentage / 100); // default 70%.\n    }\n\n    // for admin to donate money to charitable organization.\n    // This is the main purpose of this lottery game.\n    function doCharityDonation() onlyAdmin external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function generateNumbers() private view returns(uint8[6] memory) {\n        uint8[6] memory numbers;\n        uint randomNumber = uint(keccak256(abi.encodePacked(block.timestamp, msg.sender)));\n        \n        for(uint8 i=0; i<6; i++) {\n            uint8 number = uint8(randomNumber % 49) + 1;\n            while(numberExists(numbers, number)) {\n                randomNumber = uint(keccak256(abi.encodePacked(randomNumber)));\n                number = uint8(randomNumber % 49) + 1;\n            }\n            numbers[i] = number;\n            randomNumber = uint(keccak256(abi.encodePacked(randomNumber)));\n        }\n        \n        return numbers;\n    }\n    \n    function numberExists(uint8[6] memory array, uint8 number) private pure returns(bool) {\n        for(uint8 i=0; i<array.length; i++) {\n            if(array[i] == number) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function checkWinner(uint8[6] memory playerNums, uint8[6] memory winnerNums) private pure returns(bool) {\n        require(playerNums.length == winnerNums.length, \"Player number length should be equal to winner number length.\");\n        bool isWinner = true;\n        for(uint8 i =0; i < winnerNums.length; i++) {\n            if (playerNums[i] != winnerNums[i]) {\n                isWinner = false;\n                break;\n            }\n        }\n        return isWinner;\n    }\n\n}\n"
    },
    "src/PoolWithHigherInterest.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.8.2 <0.9.0;\n\ncontract PoolWithHigherInterest {\n\n    struct User {\n\t    uint balance;\n        uint lastUpdateTime;\n        string name;\n} \n\n    event Refund(address customer);\n\n    mapping (address => User) public users;\n    address payable admin;\n    uint public funds;\n    uint public totalInterest;\n    uint public lastUpdate;\n    uint public interestRate;\n    uint public investedAmount;\n    uint public lowestDepositAmount;\n\n    constructor() {\n        admin = payable(msg.sender);\n        funds = 0;\n        totalInterest = 0;\n        lastUpdate = block.timestamp;\n        interestRate = 4;\n        investedAmount = 0;\n        lowestDepositAmount = 3*(10**18);\n    }\n\n    modifier onlyOwner{\n        require(msg.sender == admin, \"can only be called by the owner\");\n        _;\n    }\n\n    modifier isRegistered() {\n        require(users[msg.sender].lastUpdateTime > 0, \"This user is not registered\");\n        _;\n    }\n\n    function getBalance() public view isRegistered returns (uint) {\n        return users[msg.sender].balance + calculateInterest(msg.sender);\n    }\n\n    function getLowestDepositAmount() public view returns (uint) {\n        return lowestDepositAmount;\n    }\n\n    function getInterestRate() public view onlyOwner returns (uint) {\n        return interestRate;\n    }\n\n    function getFunds() public view onlyOwner returns (uint) {\n        return funds;\n    }\n\n    function getInvestedAmount() public view onlyOwner returns (uint){\n        return investedAmount;\n    }\n\n    function changeRate(uint newRate) external onlyOwner{\n        interestRate = newRate;\n    }\n\n    function changeLowestDepositAmount(uint value)external onlyOwner{\n        lowestDepositAmount = value;\n    }\n\n    function register(string memory name) public {\n        require((bytes(name)).length != 0, \"Name is not provided\");\n        User memory user = User({\n                balance: 0,\n                lastUpdateTime: block.timestamp,\n                name: name\n            });\n        users[msg.sender] = user;\n    }\n\n    function deposit() external isRegistered payable  {\n        require(msg.value >= lowestDepositAmount, \"Deposit amount can not be less than lowestDepositAmount\");\n        updateBalance(msg.sender);\n        \n        users[msg.sender].balance += msg.value;\n        users[msg.sender].lastUpdateTime = block.timestamp;\n        funds += msg.value;\n    }\n\n    function withdraw(uint amount) external isRegistered {\n        require(amount > 0, \"Withdrawal amount must be greater than zero\");\n        require(users[msg.sender].balance >= amount, \"Insufficient balance\");\n        \n        updateBalance(msg.sender);\n\n        users[msg.sender].balance -= amount;\n        users[msg.sender].lastUpdateTime = block.timestamp;\n        funds -= amount;\n\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Withdrawal failed\");\n    }\n\n    function updateBalance(address user)internal{\n        uint interest = calculateInterest(user);\n        lastUpdate = block.timestamp;\n        totalInterest += interest;\n        users[user].balance += interest;\n        users[user].lastUpdateTime = block.timestamp;\n    }\n\n    function calculateInterest(address user) internal view returns(uint){\n        uint timePassed = block.timestamp - users[user].lastUpdateTime;\n        uint interest = (users[user].balance * interestRate * timePassed) / (365 days * 100);\n        return interest;\n    }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}